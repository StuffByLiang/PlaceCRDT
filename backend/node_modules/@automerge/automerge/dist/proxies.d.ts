import { Text } from "./text";
import { Automerge, type Heads, type ObjID, type Prop } from "@automerge/automerge-wasm";
import type { AutomergeValue, MapValue, ListValue } from "./types";
import { type AutomergeValue as UnstableAutomergeValue, MapValue as UnstableMapValue, ListValue as UnstableListValue } from "./unstable_types";
type TargetCommon = {
    context: Automerge;
    objectId: ObjID;
    path: Array<Prop>;
    readonly: boolean;
    heads?: Array<string>;
    cache: object;
    trace?: any;
    frozen: boolean;
};
export type Text2Target = TargetCommon & {
    textV2: true;
};
export type Text1Target = TargetCommon & {
    textV2: false;
};
export type Target = Text1Target | Text2Target;
export type ValueType<T extends Target> = T extends Text2Target ? UnstableAutomergeValue : T extends Text1Target ? AutomergeValue : never;
type MapValueType<T extends Target> = T extends Text2Target ? UnstableMapValue : T extends Text1Target ? MapValue : never;
type ListValueType<T extends Target> = T extends Text2Target ? UnstableListValue : T extends Text1Target ? ListValue : never;
export declare function mapProxy<T extends Target>(context: Automerge, objectId: ObjID, textV2: boolean, path?: Prop[], readonly?: boolean, heads?: Heads): MapValueType<T>;
export declare function listProxy<T extends Target>(context: Automerge, objectId: ObjID, textV2: boolean, path?: Prop[], readonly?: boolean, heads?: Heads): ListValueType<T>;
interface TextProxy extends Text {
    splice: (index: any, del: any, ...vals: any[]) => void;
}
export declare function textProxy(context: Automerge, objectId: ObjID, path?: Prop[], readonly?: boolean, heads?: Heads): TextProxy;
export declare function rootProxy<T>(context: Automerge, textV2: boolean, readonly?: boolean): T;
export {};

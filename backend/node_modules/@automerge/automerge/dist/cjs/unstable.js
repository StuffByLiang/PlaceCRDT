"use strict";
/**
 * # The unstable API
 *
 * This module contains new features we are working on which are either not yet
 * ready for a stable release and/or which will result in backwards incompatible
 * API changes. The API of this module may change in arbitrary ways between
 * point releases - we will always document what these changes are in the
 * [CHANGELOG](#changelog) below, but only depend on this module if you are prepared to deal
 * with frequent changes.
 *
 * ## Differences from stable
 *
 * In the stable API text objects are represented using the {@link Text} class.
 * This means you must decide up front whether your string data might need
 * concurrent merges in the future and if you change your mind you have to
 * figure out how to migrate your data. In the unstable API the `Text` class is
 * gone and all `string`s are represented using the text CRDT, allowing for
 * concurrent changes. Modifying a string is done using the {@link splice}
 * function. You can still access the old behaviour of strings which do not
 * support merging behaviour via the {@link RawString} class.
 *
 * This leads to the following differences from `stable`:
 *
 * * There is no `unstable.Text` class, all strings are text objects
 * * Reading strings in an `unstable` document is the same as reading any other
 *   javascript string
 * * To modify strings in an `unstable` document use {@link splice}
 * * The {@link AutomergeValue} type does not include the {@link Text}
 *   class but the  {@link RawString} class is included in the {@link ScalarValue}
 *   type
 *
 * ## CHANGELOG
 * * Introduce this module to expose the new API which has no `Text` class
 *
 *
 * @module
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConflicts = exports.splice = exports.load = exports.from = exports.clone = exports.init = exports.getBackend = exports.RawString = exports.getObjectId = exports.isAutomerge = exports.toJS = exports.dump = exports.getMissingDeps = exports.decodeSyncMessage = exports.encodeSyncMessage = exports.decodeChange = exports.encodeChange = exports.initSyncState = exports.receiveSyncMessage = exports.generateSyncMessage = exports.decodeSyncState = exports.encodeSyncState = exports.equals = exports.getHistory = exports.applyChanges = exports.getAllChanges = exports.getChanges = exports.getLastLocalChange = exports.getActorId = exports.merge = exports.save = exports.loadIncremental = exports.emptyChange = exports.change = exports.getHeads = exports.free = exports.view = exports.Float64 = exports.Uint = exports.Int = exports.Counter = void 0;
var unstable_types_1 = require("./unstable_types");
Object.defineProperty(exports, "Counter", { enumerable: true, get: function () { return unstable_types_1.Counter; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return unstable_types_1.Int; } });
Object.defineProperty(exports, "Uint", { enumerable: true, get: function () { return unstable_types_1.Uint; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return unstable_types_1.Float64; } });
const conflicts_1 = require("./conflicts");
var stable_1 = require("./stable");
Object.defineProperty(exports, "view", { enumerable: true, get: function () { return stable_1.view; } });
Object.defineProperty(exports, "free", { enumerable: true, get: function () { return stable_1.free; } });
Object.defineProperty(exports, "getHeads", { enumerable: true, get: function () { return stable_1.getHeads; } });
Object.defineProperty(exports, "change", { enumerable: true, get: function () { return stable_1.change; } });
Object.defineProperty(exports, "emptyChange", { enumerable: true, get: function () { return stable_1.emptyChange; } });
Object.defineProperty(exports, "loadIncremental", { enumerable: true, get: function () { return stable_1.loadIncremental; } });
Object.defineProperty(exports, "save", { enumerable: true, get: function () { return stable_1.save; } });
Object.defineProperty(exports, "merge", { enumerable: true, get: function () { return stable_1.merge; } });
Object.defineProperty(exports, "getActorId", { enumerable: true, get: function () { return stable_1.getActorId; } });
Object.defineProperty(exports, "getLastLocalChange", { enumerable: true, get: function () { return stable_1.getLastLocalChange; } });
Object.defineProperty(exports, "getChanges", { enumerable: true, get: function () { return stable_1.getChanges; } });
Object.defineProperty(exports, "getAllChanges", { enumerable: true, get: function () { return stable_1.getAllChanges; } });
Object.defineProperty(exports, "applyChanges", { enumerable: true, get: function () { return stable_1.applyChanges; } });
Object.defineProperty(exports, "getHistory", { enumerable: true, get: function () { return stable_1.getHistory; } });
Object.defineProperty(exports, "equals", { enumerable: true, get: function () { return stable_1.equals; } });
Object.defineProperty(exports, "encodeSyncState", { enumerable: true, get: function () { return stable_1.encodeSyncState; } });
Object.defineProperty(exports, "decodeSyncState", { enumerable: true, get: function () { return stable_1.decodeSyncState; } });
Object.defineProperty(exports, "generateSyncMessage", { enumerable: true, get: function () { return stable_1.generateSyncMessage; } });
Object.defineProperty(exports, "receiveSyncMessage", { enumerable: true, get: function () { return stable_1.receiveSyncMessage; } });
Object.defineProperty(exports, "initSyncState", { enumerable: true, get: function () { return stable_1.initSyncState; } });
Object.defineProperty(exports, "encodeChange", { enumerable: true, get: function () { return stable_1.encodeChange; } });
Object.defineProperty(exports, "decodeChange", { enumerable: true, get: function () { return stable_1.decodeChange; } });
Object.defineProperty(exports, "encodeSyncMessage", { enumerable: true, get: function () { return stable_1.encodeSyncMessage; } });
Object.defineProperty(exports, "decodeSyncMessage", { enumerable: true, get: function () { return stable_1.decodeSyncMessage; } });
Object.defineProperty(exports, "getMissingDeps", { enumerable: true, get: function () { return stable_1.getMissingDeps; } });
Object.defineProperty(exports, "dump", { enumerable: true, get: function () { return stable_1.dump; } });
Object.defineProperty(exports, "toJS", { enumerable: true, get: function () { return stable_1.toJS; } });
Object.defineProperty(exports, "isAutomerge", { enumerable: true, get: function () { return stable_1.isAutomerge; } });
Object.defineProperty(exports, "getObjectId", { enumerable: true, get: function () { return stable_1.getObjectId; } });
const stable = require("./stable");
var raw_string_1 = require("./raw_string");
Object.defineProperty(exports, "RawString", { enumerable: true, get: function () { return raw_string_1.RawString; } });
/** @hidden */
exports.getBackend = stable.getBackend;
const internal_state_1 = require("./internal_state");
/**
 * Create a new automerge document
 *
 * @typeParam T - The type of value contained in the document. This will be the
 *     type that is passed to the change closure in {@link change}
 * @param _opts - Either an actorId or an {@link InitOptions} (which may
 *     contain an actorId). If this is null the document will be initialised with a
 *     random actor ID
 */
function init(_opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return stable.init(opts);
}
exports.init = init;
/**
 * Make a full writable copy of an automerge document
 *
 * @remarks
 * Unlike {@link view} this function makes a full copy of the memory backing
 * the document and can thus be passed to {@link change}. It also generates a
 * new actor ID so that changes made in the new document do not create duplicate
 * sequence numbers with respect to the old document. If you need control over
 * the actor ID which is generated you can pass the actor ID as the second
 * argument
 *
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to clone
 * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}
 */
function clone(doc, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return stable.clone(doc, opts);
}
exports.clone = clone;
/**
 * Create an automerge document from a POJO
 *
 * @param initialState - The initial state which will be copied into the document
 * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain
 * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used
 *
 * @example
 * ```
 * const doc = automerge.from({
 *     tasks: [
 *         {description: "feed dogs", done: false}
 *     ]
 * })
 * ```
 */
function from(initialState, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return stable.from(initialState, opts);
}
exports.from = from;
/**
 * Load an automerge document from a compressed document produce by {@link save}
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressed document
 * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor
 *                ID is null a random actor ID will be created
 *
 * Note that `load` will throw an error if passed incomplete content (for
 * example if you are receiving content over the network and don't know if you
 * have the complete document yet). If you need to handle incomplete content use
 * {@link init} followed by {@link loadIncremental}.
 */
function load(data, _opts) {
    const opts = importOpts(_opts);
    opts.enableTextV2 = true;
    return stable.load(data, opts);
}
exports.load = load;
function importOpts(_actor) {
    if (typeof _actor === "object") {
        return _actor;
    }
    else {
        return { actor: _actor };
    }
}
function splice(doc, prop, index, del, newText) {
    if (!(0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("object cannot be modified outside of a change block");
    }
    const state = (0, internal_state_1._state)(doc, false);
    const objectId = (0, internal_state_1._obj)(doc);
    if (!objectId) {
        throw new RangeError("invalid object for splice");
    }
    const value = `${objectId}/${prop}`;
    try {
        return state.handle.splice(value, index, del, newText);
    }
    catch (e) {
        throw new RangeError(`Cannot splice: ${e}`);
    }
}
exports.splice = splice;
/**
 * Get the conflicts associated with a property
 *
 * The values of properties in a map in automerge can be conflicted if there
 * are concurrent "put" operations to the same key. Automerge chooses one value
 * arbitrarily (but deterministically, any two nodes who have the same set of
 * changes will choose the same value) from the set of conflicting values to
 * present as the value of the key.
 *
 * Sometimes you may want to examine these conflicts, in this case you can use
 * {@link getConflicts} to get the conflicts for the key.
 *
 * @example
 * ```
 * import * as automerge from "@automerge/automerge"
 *
 * type Profile = {
 *     pets: Array<{name: string, type: string}>
 * }
 *
 * let doc1 = automerge.init<Profile>("aaaa")
 * doc1 = automerge.change(doc1, d => {
 *     d.pets = [{name: "Lassie", type: "dog"}]
 * })
 * let doc2 = automerge.init<Profile>("bbbb")
 * doc2 = automerge.merge(doc2, automerge.clone(doc1))
 *
 * doc2 = automerge.change(doc2, d => {
 *     d.pets[0].name = "Beethoven"
 * })
 *
 * doc1 = automerge.change(doc1, d => {
 *     d.pets[0].name = "Babe"
 * })
 *
 * const doc3 = automerge.merge(doc1, doc2)
 *
 * // Note that here we pass `doc3.pets`, not `doc3`
 * let conflicts = automerge.getConflicts(doc3.pets[0], "name")
 *
 * // The two conflicting values are the keys of the conflicts object
 * assert.deepEqual(Object.values(conflicts), ["Babe", Beethoven"])
 * ```
 */
function getConflicts(doc, prop) {
    const state = (0, internal_state_1._state)(doc, false);
    if (!state.textV2) {
        throw new Error("use getConflicts for a stable document");
    }
    const objectId = (0, internal_state_1._obj)(doc);
    if (objectId != null) {
        return (0, conflicts_1.unstableConflictAt)(state.handle, objectId, prop);
    }
    else {
        return undefined;
    }
}
exports.getConflicts = getConflicts;

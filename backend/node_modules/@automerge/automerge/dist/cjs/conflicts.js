"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unstableConflictAt = exports.stableConflictAt = void 0;
const types_1 = require("./types");
const text_1 = require("./text");
const proxies_1 = require("./proxies");
function stableConflictAt(context, objectId, prop) {
    return conflictAt(context, objectId, prop, true, (context, conflictId) => {
        return new text_1.Text(context.text(conflictId));
    });
}
exports.stableConflictAt = stableConflictAt;
function unstableConflictAt(context, objectId, prop) {
    return conflictAt(context, objectId, prop, true, (context, conflictId) => {
        return context.text(conflictId);
    });
}
exports.unstableConflictAt = unstableConflictAt;
function conflictAt(context, objectId, prop, textV2, handleText) {
    const values = context.getAll(objectId, prop);
    if (values.length <= 1) {
        return;
    }
    const result = {};
    for (const fullVal of values) {
        switch (fullVal[0]) {
            case "map":
                result[fullVal[1]] = (0, proxies_1.mapProxy)(context, fullVal[1], textV2, [prop], true);
                break;
            case "list":
                result[fullVal[1]] = (0, proxies_1.listProxy)(context, fullVal[1], textV2, [prop], true);
                break;
            case "text":
                result[fullVal[1]] = handleText(context, fullVal[1]);
                break;
            case "str":
            case "uint":
            case "int":
            case "f64":
            case "boolean":
            case "bytes":
            case "null":
                result[fullVal[2]] = fullVal[1];
                break;
            case "counter":
                result[fullVal[2]] = new types_1.Counter(fullVal[1]);
                break;
            case "timestamp":
                result[fullVal[2]] = new Date(fullVal[1]);
                break;
            default:
                throw RangeError(`datatype ${fullVal[0]} unimplemented`);
        }
    }
    return result;
}

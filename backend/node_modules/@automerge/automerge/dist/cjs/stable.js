"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAutomerge = exports.toJS = exports.dump = exports.getHeads = exports.getMissingDeps = exports.decodeSyncMessage = exports.encodeSyncMessage = exports.decodeChange = exports.encodeChange = exports.initSyncState = exports.receiveSyncMessage = exports.generateSyncMessage = exports.decodeSyncState = exports.encodeSyncState = exports.equals = exports.getHistory = exports.applyChanges = exports.getAllChanges = exports.getChanges = exports.getObjectId = exports.getLastLocalChange = exports.getConflicts = exports.getActorId = exports.merge = exports.save = exports.loadIncremental = exports.load = exports.emptyChange = exports.change = exports.from = exports.free = exports.clone = exports.view = exports.init = exports.getBackend = exports.use = exports.Text = exports.Float64 = exports.Uint = exports.Int = exports.Counter = exports.uuid = void 0;
/** @hidden **/
var uuid_1 = require("./uuid");
Object.defineProperty(exports, "uuid", { enumerable: true, get: function () { return uuid_1.uuid; } });
const proxies_1 = require("./proxies");
const constants_1 = require("./constants");
const types_1 = require("./types");
var types_2 = require("./types");
Object.defineProperty(exports, "Counter", { enumerable: true, get: function () { return types_2.Counter; } });
Object.defineProperty(exports, "Int", { enumerable: true, get: function () { return types_2.Int; } });
Object.defineProperty(exports, "Uint", { enumerable: true, get: function () { return types_2.Uint; } });
Object.defineProperty(exports, "Float64", { enumerable: true, get: function () { return types_2.Float64; } });
const text_1 = require("./text");
var text_2 = require("./text");
Object.defineProperty(exports, "Text", { enumerable: true, get: function () { return text_2.Text; } });
const SyncStateSymbol = Symbol("_syncstate");
const low_level_1 = require("./low_level");
const raw_string_1 = require("./raw_string");
const internal_state_1 = require("./internal_state");
const conflicts_1 = require("./conflicts");
/** @hidden **/
function use(api) {
    (0, low_level_1.UseApi)(api);
}
exports.use = use;
const wasm = require("@automerge/automerge-wasm");
use(wasm);
/** @hidden */
function getBackend(doc) {
    return (0, internal_state_1._state)(doc).handle;
}
exports.getBackend = getBackend;
function importOpts(_actor) {
    if (typeof _actor === "object") {
        return _actor;
    }
    else {
        return { actor: _actor };
    }
}
/**
 * Create a new automerge document
 *
 * @typeParam T - The type of value contained in the document. This will be the
 *     type that is passed to the change closure in {@link change}
 * @param _opts - Either an actorId or an {@link InitOptions} (which may
 *     contain an actorId). If this is null the document will be initialised with a
 *     random actor ID
 */
function init(_opts) {
    const opts = importOpts(_opts);
    const freeze = !!opts.freeze;
    const patchCallback = opts.patchCallback;
    const handle = low_level_1.ApiHandler.create(opts.enableTextV2 || false, opts.actor);
    handle.enablePatches(true);
    handle.enableFreeze(!!opts.freeze);
    handle.registerDatatype("counter", (n) => new types_1.Counter(n));
    const textV2 = opts.enableTextV2 || false;
    if (textV2) {
        handle.registerDatatype("str", (n) => new raw_string_1.RawString(n));
    }
    else {
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        handle.registerDatatype("text", (n) => new text_1.Text(n));
    }
    const doc = handle.materialize("/", undefined, {
        handle,
        heads: undefined,
        freeze,
        patchCallback,
        textV2,
    });
    return doc;
}
exports.init = init;
/**
 * Make an immutable view of an automerge document as at `heads`
 *
 * @remarks
 * The document returned from this function cannot be passed to {@link change}.
 * This is because it shares the same underlying memory as `doc`, but it is
 * consequently a very cheap copy.
 *
 * Note that this function will throw an error if any of the hashes in `heads`
 * are not in the document.
 *
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to create a view of
 * @param heads - The hashes of the heads to create a view at
 */
function view(doc, heads) {
    const state = (0, internal_state_1._state)(doc);
    const handle = state.handle;
    return state.handle.materialize("/", heads, Object.assign(Object.assign({}, state), { handle,
        heads }));
}
exports.view = view;
/**
 * Make a full writable copy of an automerge document
 *
 * @remarks
 * Unlike {@link view} this function makes a full copy of the memory backing
 * the document and can thus be passed to {@link change}. It also generates a
 * new actor ID so that changes made in the new document do not create duplicate
 * sequence numbers with respect to the old document. If you need control over
 * the actor ID which is generated you can pass the actor ID as the second
 * argument
 *
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to clone
 * @param _opts - Either an actor ID to use for the new doc or an {@link InitOptions}
 */
function clone(doc, _opts) {
    const state = (0, internal_state_1._state)(doc);
    const heads = state.heads;
    const opts = importOpts(_opts);
    const handle = state.handle.fork(opts.actor, heads);
    // `change` uses the presence of state.heads to determine if we are in a view
    // set it to undefined to indicate that this is a full fat document
    const { heads: _oldHeads } = state, stateSansHeads = __rest(state, ["heads"]);
    return handle.applyPatches(doc, Object.assign(Object.assign({}, stateSansHeads), { handle }));
}
exports.clone = clone;
/** Explicity free the memory backing a document. Note that this is note
 * necessary in environments which support
 * [`FinalizationRegistry`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry)
 */
function free(doc) {
    return (0, internal_state_1._state)(doc).handle.free();
}
exports.free = free;
/**
 * Create an automerge document from a POJO
 *
 * @param initialState - The initial state which will be copied into the document
 * @typeParam T - The type of the value passed to `from` _and_ the type the resulting document will contain
 * @typeParam actor - The actor ID of the resulting document, if this is null a random actor ID will be used
 *
 * @example
 * ```
 * const doc = automerge.from({
 *     tasks: [
 *         {description: "feed dogs", done: false}
 *     ]
 * })
 * ```
 */
function from(initialState, _opts) {
    return change(init(_opts), d => Object.assign(d, initialState));
}
exports.from = from;
/**
 * Update the contents of an automerge document
 * @typeParam T - The type of the value contained in the document
 * @param doc - The document to update
 * @param options - Either a message, an {@link ChangeOptions}, or a {@link ChangeFn}
 * @param callback - A `ChangeFn` to be used if `options` was a `string`
 *
 * Note that if the second argument is a function it will be used as the `ChangeFn` regardless of what the third argument is.
 *
 * @example A simple change
 * ```
 * let doc1 = automerge.init()
 * doc1 = automerge.change(doc1, d => {
 *     d.key = "value"
 * })
 * assert.equal(doc1.key, "value")
 * ```
 *
 * @example A change with a message
 *
 * ```
 * doc1 = automerge.change(doc1, "add another value", d => {
 *     d.key2 = "value2"
 * })
 * ```
 *
 * @example A change with a message and a timestamp
 *
 * ```
 * doc1 = automerge.change(doc1, {message: "add another value", timestamp: 1640995200}, d => {
 *     d.key2 = "value2"
 * })
 * ```
 *
 * @example responding to a patch callback
 * ```
 * let patchedPath
 * let patchCallback = patch => {
 *    patchedPath = patch.path
 * }
 * doc1 = automerge.change(doc1, {message, "add another value", timestamp: 1640995200, patchCallback}, d => {
 *     d.key2 = "value2"
 * })
 * assert.equal(patchedPath, ["key2"])
 * ```
 */
function change(doc, options, callback) {
    if (typeof options === "function") {
        return _change(doc, {}, options);
    }
    else if (typeof callback === "function") {
        if (typeof options === "string") {
            options = { message: options };
        }
        return _change(doc, options, callback);
    }
    else {
        throw RangeError("Invalid args for change");
    }
}
exports.change = change;
function progressDocument(doc, heads, callback) {
    if (heads == null) {
        return doc;
    }
    const state = (0, internal_state_1._state)(doc);
    const nextState = Object.assign(Object.assign({}, state), { heads: undefined });
    const nextDoc = state.handle.applyPatches(doc, nextState, callback);
    state.heads = heads;
    return nextDoc;
}
function _change(doc, options, callback) {
    if (typeof callback !== "function") {
        throw new RangeError("invalid change function");
    }
    const state = (0, internal_state_1._state)(doc);
    if (doc === undefined || state === undefined) {
        throw new RangeError("must be the document root");
    }
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if ((0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    try {
        state.heads = heads;
        const root = (0, proxies_1.rootProxy)(state.handle, state.textV2);
        callback(root);
        if (state.handle.pendingOps() === 0) {
            state.heads = undefined;
            return doc;
        }
        else {
            state.handle.commit(options.message, options.time);
            return progressDocument(doc, heads, options.patchCallback || state.patchCallback);
        }
    }
    catch (e) {
        state.heads = undefined;
        state.handle.rollback();
        throw e;
    }
}
/**
 * Make a change to a document which does not modify the document
 *
 * @param doc - The doc to add the empty change to
 * @param options - Either a message or a {@link ChangeOptions} for the new change
 *
 * Why would you want to do this? One reason might be that you have merged
 * changes from some other peers and you want to generate a change which
 * depends on those merged changes so that you can sign the new change with all
 * of the merged changes as part of the new change.
 */
function emptyChange(doc, options) {
    if (options === undefined) {
        options = {};
    }
    if (typeof options === "string") {
        options = { message: options };
    }
    const state = (0, internal_state_1._state)(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if ((0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.emptyChange(options.message, options.time);
    return progressDocument(doc, heads);
}
exports.emptyChange = emptyChange;
/**
 * Load an automerge document from a compressed document produce by {@link save}
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressed document
 * @param _opts - Either an actor ID or some {@link InitOptions}, if the actor
 *                ID is null a random actor ID will be created
 *
 * Note that `load` will throw an error if passed incomplete content (for
 * example if you are receiving content over the network and don't know if you
 * have the complete document yet). If you need to handle incomplete content use
 * {@link init} followed by {@link loadIncremental}.
 */
function load(data, _opts) {
    const opts = importOpts(_opts);
    const actor = opts.actor;
    const patchCallback = opts.patchCallback;
    const handle = low_level_1.ApiHandler.load(data, opts.enableTextV2 || false, actor);
    handle.enablePatches(true);
    handle.enableFreeze(!!opts.freeze);
    handle.registerDatatype("counter", (n) => new types_1.Counter(n));
    const textV2 = opts.enableTextV2 || false;
    if (textV2) {
        handle.registerDatatype("str", (n) => new raw_string_1.RawString(n));
    }
    else {
        handle.registerDatatype("text", (n) => new text_1.Text(n));
    }
    const doc = handle.materialize("/", undefined, {
        handle,
        heads: undefined,
        patchCallback,
        textV2,
    });
    return doc;
}
exports.load = load;
/**
 * Load changes produced by {@link saveIncremental}, or partial changes
 *
 * @typeParam T - The type of the value which is contained in the document.
 *                Note that no validation is done to make sure this type is in
 *                fact the type of the contained value so be a bit careful
 * @param data  - The compressedchanges
 * @param opts  - an {@link ApplyOptions}
 *
 * This function is useful when staying up to date with a connected peer.
 * Perhaps the other end sent you a full compresed document which you loaded
 * with {@link load} and they're sending you the result of
 * {@link getLastLocalChange} every time they make a change.
 *
 * Note that this function will succesfully load the results of {@link save} as
 * well as {@link getLastLocalChange} or any other incremental change.
 */
function loadIncremental(doc, data, opts) {
    if (!opts) {
        opts = {};
    }
    const state = (0, internal_state_1._state)(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an out of date document - set at: " + (0, internal_state_1._trace)(doc));
    }
    if ((0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.loadIncremental(data);
    return progressDocument(doc, heads, opts.patchCallback || state.patchCallback);
}
exports.loadIncremental = loadIncremental;
/**
 * Export the contents of a document to a compressed format
 *
 * @param doc - The doc to save
 *
 * The returned bytes can be passed to {@link load} or {@link loadIncremental}
 */
function save(doc) {
    return (0, internal_state_1._state)(doc).handle.save();
}
exports.save = save;
/**
 * Merge `local` into `remote`
 * @typeParam T - The type of values contained in each document
 * @param local - The document to merge changes into
 * @param remote - The document to merge changes from
 *
 * @returns - The merged document
 *
 * Often when you are merging documents you will also need to clone them. Both
 * arguments to `merge` are frozen after the call so you can no longer call
 * mutating methods (such as {@link change}) on them. The symtom of this will be
 * an error which says "Attempting to change an out of date document". To
 * overcome this call {@link clone} on the argument before passing it to {@link
 * merge}.
 */
function merge(local, remote) {
    const localState = (0, internal_state_1._state)(local);
    if (localState.heads) {
        throw new RangeError("Attempting to change an out of date document - set at: " + (0, internal_state_1._trace)(local));
    }
    const heads = localState.handle.getHeads();
    const remoteState = (0, internal_state_1._state)(remote);
    const changes = localState.handle.getChangesAdded(remoteState.handle);
    localState.handle.applyChanges(changes);
    return progressDocument(local, heads, localState.patchCallback);
}
exports.merge = merge;
/**
 * Get the actor ID associated with the document
 */
function getActorId(doc) {
    const state = (0, internal_state_1._state)(doc);
    return state.handle.getActorId();
}
exports.getActorId = getActorId;
/**
 * Get the conflicts associated with a property
 *
 * The values of properties in a map in automerge can be conflicted if there
 * are concurrent "put" operations to the same key. Automerge chooses one value
 * arbitrarily (but deterministically, any two nodes who have the same set of
 * changes will choose the same value) from the set of conflicting values to
 * present as the value of the key.
 *
 * Sometimes you may want to examine these conflicts, in this case you can use
 * {@link getConflicts} to get the conflicts for the key.
 *
 * @example
 * ```
 * import * as automerge from "@automerge/automerge"
 *
 * type Profile = {
 *     pets: Array<{name: string, type: string}>
 * }
 *
 * let doc1 = automerge.init<Profile>("aaaa")
 * doc1 = automerge.change(doc1, d => {
 *     d.pets = [{name: "Lassie", type: "dog"}]
 * })
 * let doc2 = automerge.init<Profile>("bbbb")
 * doc2 = automerge.merge(doc2, automerge.clone(doc1))
 *
 * doc2 = automerge.change(doc2, d => {
 *     d.pets[0].name = "Beethoven"
 * })
 *
 * doc1 = automerge.change(doc1, d => {
 *     d.pets[0].name = "Babe"
 * })
 *
 * const doc3 = automerge.merge(doc1, doc2)
 *
 * // Note that here we pass `doc3.pets`, not `doc3`
 * let conflicts = automerge.getConflicts(doc3.pets[0], "name")
 *
 * // The two conflicting values are the keys of the conflicts object
 * assert.deepEqual(Object.values(conflicts), ["Babe", Beethoven"])
 * ```
 */
function getConflicts(doc, prop) {
    const state = (0, internal_state_1._state)(doc, false);
    if (state.textV2) {
        throw new Error("use unstable.getConflicts for an unstable document");
    }
    const objectId = (0, internal_state_1._obj)(doc);
    if (objectId != null) {
        return (0, conflicts_1.stableConflictAt)(state.handle, objectId, prop);
    }
    else {
        return undefined;
    }
}
exports.getConflicts = getConflicts;
/**
 * Get the binary representation of the last change which was made to this doc
 *
 * This is most useful when staying in sync with other peers, every time you
 * make a change locally via {@link change} you immediately call {@link
 * getLastLocalChange} and send the result over the network to other peers.
 */
function getLastLocalChange(doc) {
    const state = (0, internal_state_1._state)(doc);
    return state.handle.getLastLocalChange() || undefined;
}
exports.getLastLocalChange = getLastLocalChange;
/**
 * Return the object ID of an arbitrary javascript value
 *
 * This is useful to determine if something is actually an automerge document,
 * if `doc` is not an automerge document this will return null.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function getObjectId(doc, prop) {
    if (prop) {
        const state = (0, internal_state_1._state)(doc, false);
        const objectId = (0, internal_state_1._obj)(doc);
        if (!state || !objectId) {
            return null;
        }
        return state.handle.get(objectId, prop);
    }
    else {
        return (0, internal_state_1._obj)(doc);
    }
}
exports.getObjectId = getObjectId;
/**
 * Get the changes which are in `newState` but not in `oldState`. The returned
 * changes can be loaded in `oldState` via {@link applyChanges}.
 *
 * Note that this will crash if there are changes in `oldState` which are not in `newState`.
 */
function getChanges(oldState, newState) {
    const n = (0, internal_state_1._state)(newState);
    return n.handle.getChanges(getHeads(oldState));
}
exports.getChanges = getChanges;
/**
 * Get all the changes in a document
 *
 * This is different to {@link save} because the output is an array of changes
 * which can be individually applied via {@link applyChanges}`
 *
 */
function getAllChanges(doc) {
    const state = (0, internal_state_1._state)(doc);
    return state.handle.getChanges([]);
}
exports.getAllChanges = getAllChanges;
/**
 * Apply changes received from another document
 *
 * `doc` will be updated to reflect the `changes`. If there are changes which
 * we do not have dependencies for yet those will be stored in the document and
 * applied when the depended on changes arrive.
 *
 * You can use the {@link ApplyOptions} to pass a patchcallback which will be
 * informed of any changes which occur as a result of applying the changes
 *
 */
function applyChanges(doc, changes, opts) {
    const state = (0, internal_state_1._state)(doc);
    if (!opts) {
        opts = {};
    }
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if ((0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.applyChanges(changes);
    state.heads = heads;
    return [
        progressDocument(doc, heads, opts.patchCallback || state.patchCallback),
    ];
}
exports.applyChanges = applyChanges;
/** @hidden */
function getHistory(doc) {
    const textV2 = (0, internal_state_1._state)(doc).textV2;
    const history = getAllChanges(doc);
    return history.map((change, index) => ({
        get change() {
            return decodeChange(change);
        },
        get snapshot() {
            const [state] = applyChanges(init({ enableTextV2: textV2 }), history.slice(0, index + 1));
            return state;
        },
    }));
}
exports.getHistory = getHistory;
/** @hidden */
// FIXME : no tests
// FIXME can we just use deep equals now?
function equals(val1, val2) {
    if (!isObject(val1) || !isObject(val2))
        return val1 === val2;
    const keys1 = Object.keys(val1).sort(), keys2 = Object.keys(val2).sort();
    if (keys1.length !== keys2.length)
        return false;
    for (let i = 0; i < keys1.length; i++) {
        if (keys1[i] !== keys2[i])
            return false;
        if (!equals(val1[keys1[i]], val2[keys2[i]]))
            return false;
    }
    return true;
}
exports.equals = equals;
/**
 * encode a {@link SyncState} into binary to send over the network
 *
 * @group sync
 * */
function encodeSyncState(state) {
    const sync = low_level_1.ApiHandler.importSyncState(state);
    const result = low_level_1.ApiHandler.encodeSyncState(sync);
    sync.free();
    return result;
}
exports.encodeSyncState = encodeSyncState;
/**
 * Decode some binary data into a {@link SyncState}
 *
 * @group sync
 */
function decodeSyncState(state) {
    const sync = low_level_1.ApiHandler.decodeSyncState(state);
    const result = low_level_1.ApiHandler.exportSyncState(sync);
    sync.free();
    return result;
}
exports.decodeSyncState = decodeSyncState;
/**
 * Generate a sync message to send to the peer represented by `inState`
 * @param doc - The doc to generate messages about
 * @param inState - The {@link SyncState} representing the peer we are talking to
 *
 * @group sync
 *
 * @returns An array of `[newSyncState, syncMessage | null]` where
 * `newSyncState` should replace `inState` and `syncMessage` should be sent to
 * the peer if it is not null. If `syncMessage` is null then we are up to date.
 */
function generateSyncMessage(doc, inState) {
    const state = (0, internal_state_1._state)(doc);
    const syncState = low_level_1.ApiHandler.importSyncState(inState);
    const message = state.handle.generateSyncMessage(syncState);
    const outState = low_level_1.ApiHandler.exportSyncState(syncState);
    return [outState, message];
}
exports.generateSyncMessage = generateSyncMessage;
/**
 * Update a document and our sync state on receiving a sync message
 *
 * @group sync
 *
 * @param doc     - The doc the sync message is about
 * @param inState - The {@link SyncState} for the peer we are communicating with
 * @param message - The message which was received
 * @param opts    - Any {@link ApplyOption}s, used for passing a
 *                  {@link PatchCallback} which will be informed of any changes
 *                  in `doc` which occur because of the received sync message.
 *
 * @returns An array of `[newDoc, newSyncState, syncMessage | null]` where
 * `newDoc` is the updated state of `doc`, `newSyncState` should replace
 * `inState` and `syncMessage` should be sent to the peer if it is not null. If
 * `syncMessage` is null then we are up to date.
 */
function receiveSyncMessage(doc, inState, message, opts) {
    const syncState = low_level_1.ApiHandler.importSyncState(inState);
    if (!opts) {
        opts = {};
    }
    const state = (0, internal_state_1._state)(doc);
    if (state.heads) {
        throw new RangeError("Attempting to change an outdated document.  Use Automerge.clone() if you wish to make a writable copy.");
    }
    if ((0, internal_state_1._is_proxy)(doc)) {
        throw new RangeError("Calls to Automerge.change cannot be nested");
    }
    const heads = state.handle.getHeads();
    state.handle.receiveSyncMessage(syncState, message);
    const outSyncState = low_level_1.ApiHandler.exportSyncState(syncState);
    return [
        progressDocument(doc, heads, opts.patchCallback || state.patchCallback),
        outSyncState,
        null,
    ];
}
exports.receiveSyncMessage = receiveSyncMessage;
/**
 * Create a new, blank {@link SyncState}
 *
 * When communicating with a peer for the first time use this to generate a new
 * {@link SyncState} for them
 *
 * @group sync
 */
function initSyncState() {
    return low_level_1.ApiHandler.exportSyncState(low_level_1.ApiHandler.initSyncState());
}
exports.initSyncState = initSyncState;
/** @hidden */
function encodeChange(change) {
    return low_level_1.ApiHandler.encodeChange(change);
}
exports.encodeChange = encodeChange;
/** @hidden */
function decodeChange(data) {
    return low_level_1.ApiHandler.decodeChange(data);
}
exports.decodeChange = decodeChange;
/** @hidden */
function encodeSyncMessage(message) {
    return low_level_1.ApiHandler.encodeSyncMessage(message);
}
exports.encodeSyncMessage = encodeSyncMessage;
/** @hidden */
function decodeSyncMessage(message) {
    return low_level_1.ApiHandler.decodeSyncMessage(message);
}
exports.decodeSyncMessage = decodeSyncMessage;
/**
 * Get any changes in `doc` which are not dependencies of `heads`
 */
function getMissingDeps(doc, heads) {
    const state = (0, internal_state_1._state)(doc);
    return state.handle.getMissingDeps(heads);
}
exports.getMissingDeps = getMissingDeps;
/**
 * Get the hashes of the heads of this document
 */
function getHeads(doc) {
    const state = (0, internal_state_1._state)(doc);
    return state.heads || state.handle.getHeads();
}
exports.getHeads = getHeads;
/** @hidden */
function dump(doc) {
    const state = (0, internal_state_1._state)(doc);
    state.handle.dump();
}
exports.dump = dump;
/** @hidden */
function toJS(doc) {
    const state = (0, internal_state_1._state)(doc);
    const enabled = state.handle.enableFreeze(false);
    const result = state.handle.materialize();
    state.handle.enableFreeze(enabled);
    return result;
}
exports.toJS = toJS;
function isAutomerge(doc) {
    if (typeof doc == "object" && doc !== null) {
        return getObjectId(doc) === "_root" && !!Reflect.get(doc, constants_1.STATE);
    }
    else {
        return false;
    }
}
exports.isAutomerge = isAutomerge;
function isObject(obj) {
    return typeof obj === "object" && obj !== null;
}
